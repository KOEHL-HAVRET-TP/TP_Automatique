<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TP_Automatique_doxygen: ADC_InitTypeDef Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TP_Automatique_doxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_a_d_c___init_type_def-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ADC_InitTypeDef Struct Reference<div class="ingroups"><a class="el" href="group___s_t_m32_g4xx___h_a_l___driver.html">STM32G4xx_HAL_Driver</a> &raquo; <a class="el" href="group___a_d_c.html">ADC</a> &raquo; <a class="el" href="group___a_d_c___exported___types.html">ADC Exported Types</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Structure definition of ADC instance and ADC group regular.  
 <a href="struct_a_d_c___init_type_def.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="stm32g4xx__hal__adc_8h_source.html">stm32g4xx_hal_adc.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7e49d0db9ef7db8806bbfa57a1bd73a6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#a7e49d0db9ef7db8806bbfa57a1bd73a6">ClockPrescaler</a></td></tr>
<tr class="separator:a7e49d0db9ef7db8806bbfa57a1bd73a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebb8d3277cb9a5aae72578076762f5d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#abebb8d3277cb9a5aae72578076762f5d">Resolution</a></td></tr>
<tr class="separator:abebb8d3277cb9a5aae72578076762f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ec9040d55aa68c23d92d174b464ac1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#af9ec9040d55aa68c23d92d174b464ac1">DataAlign</a></td></tr>
<tr class="separator:af9ec9040d55aa68c23d92d174b464ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54504ce05c131459ce3404c416569e9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#ac54504ce05c131459ce3404c416569e9">GainCompensation</a></td></tr>
<tr class="separator:ac54504ce05c131459ce3404c416569e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cd689a52562a2481059a5d8ed82788"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#a47cd689a52562a2481059a5d8ed82788">ScanConvMode</a></td></tr>
<tr class="separator:a47cd689a52562a2481059a5d8ed82788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3eedd269c3acc6c6933e8a252c36e71"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#ae3eedd269c3acc6c6933e8a252c36e71">EOCSelection</a></td></tr>
<tr class="separator:ae3eedd269c3acc6c6933e8a252c36e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce1d078350e06a4f8850207d0b81271"><td class="memItemLeft" align="right" valign="top">FunctionalState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#afce1d078350e06a4f8850207d0b81271">LowPowerAutoWait</a></td></tr>
<tr class="separator:afce1d078350e06a4f8850207d0b81271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc1365e223886a079d7c673f0f90b56"><td class="memItemLeft" align="right" valign="top">FunctionalState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#a1fc1365e223886a079d7c673f0f90b56">ContinuousConvMode</a></td></tr>
<tr class="separator:a1fc1365e223886a079d7c673f0f90b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72b0cc3e8dac3a30097cf12093c42a7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#aa72b0cc3e8dac3a30097cf12093c42a7">NbrOfConversion</a></td></tr>
<tr class="separator:aa72b0cc3e8dac3a30097cf12093c42a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb62fa7128d7c97d53d2eb170ad467eb"><td class="memItemLeft" align="right" valign="top">FunctionalState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#afb62fa7128d7c97d53d2eb170ad467eb">DiscontinuousConvMode</a></td></tr>
<tr class="separator:afb62fa7128d7c97d53d2eb170ad467eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0078be814bfe2608ae5758826eafb8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#a5c0078be814bfe2608ae5758826eafb8">NbrOfDiscConversion</a></td></tr>
<tr class="separator:a5c0078be814bfe2608ae5758826eafb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47aba277f9d8f3c5774983de4ce9455b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#a47aba277f9d8f3c5774983de4ce9455b">ExternalTrigConv</a></td></tr>
<tr class="separator:a47aba277f9d8f3c5774983de4ce9455b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed14631d5f1d118a252ea24edd68ede"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#aeed14631d5f1d118a252ea24edd68ede">ExternalTrigConvEdge</a></td></tr>
<tr class="separator:aeed14631d5f1d118a252ea24edd68ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a8fd245e5e79329d289c3c2381bd0d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#a03a8fd245e5e79329d289c3c2381bd0d">SamplingMode</a></td></tr>
<tr class="separator:a03a8fd245e5e79329d289c3c2381bd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c35c52d6f47c62915fa7d011e526510"><td class="memItemLeft" align="right" valign="top">FunctionalState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#a2c35c52d6f47c62915fa7d011e526510">DMAContinuousRequests</a></td></tr>
<tr class="separator:a2c35c52d6f47c62915fa7d011e526510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63237364ceaf8692adea5dd58420086a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#a63237364ceaf8692adea5dd58420086a">Overrun</a></td></tr>
<tr class="separator:a63237364ceaf8692adea5dd58420086a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693ef3079c6f2c8588beacb44fce185f"><td class="memItemLeft" align="right" valign="top">FunctionalState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#a693ef3079c6f2c8588beacb44fce185f">OversamplingMode</a></td></tr>
<tr class="separator:a693ef3079c6f2c8588beacb44fce185f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b1be3b90d94f331e3688b8f3df528d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_d_c___oversampling_type_def.html">ADC_OversamplingTypeDef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c___init_type_def.html#af2b1be3b90d94f331e3688b8f3df528d">Oversampling</a></td></tr>
<tr class="separator:af2b1be3b90d94f331e3688b8f3df528d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Structure definition of ADC instance and ADC group regular. </p>
<dl class="section note"><dt>Note</dt><dd>Parameters of this structure are shared within 2 scopes:<ul>
<li>Scope entire ADC (affects ADC groups regular and injected): ClockPrescaler, Resolution, DataAlign, GainCompensation, ScanConvMode, EOCSelection, LowPowerAutoWait.</li>
<li>Scope ADC group regular: ContinuousConvMode, NbrOfConversion, DiscontinuousConvMode, NbrOfDiscConversion, ExternalTrigConv, ExternalTrigConvEdge, DMAContinuousRequests, Overrun, OversamplingMode, Oversampling, SamplingMode. </li>
</ul>
</dd>
<dd>
The setting of these parameters by function HAL_ADC_Init() is conditioned to ADC state. ADC state can be either:<ul>
<li>For all parameters: ADC disabled</li>
<li>For all parameters except 'LowPowerAutoWait', 'DMAContinuousRequests' and 'Oversampling': ADC enabled without conversion on going on group regular.</li>
<li>For parameters 'LowPowerAutoWait' and 'DMAContinuousRequests': ADC enabled without conversion on going on groups regular and injected. If ADC is not in the appropriate state to modify some parameters, these parameters setting is bypassed without error reporting (as it can be the expected behavior in case of intended action to update another parameter (which fulfills the ADC state condition) on the fly). </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="a7e49d0db9ef7db8806bbfa57a1bd73a6" name="a7e49d0db9ef7db8806bbfa57a1bd73a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e49d0db9ef7db8806bbfa57a1bd73a6">&#9670;&#160;</a></span>ClockPrescaler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ADC_InitTypeDef::ClockPrescaler</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Select ADC clock source (synchronous clock derived from APB clock or asynchronous clock derived from system clock or PLL (Refer to reference manual for list of clocks available)) and clock prescaler. This parameter can be a value of <a class="el" href="group___a_d_c___h_a_l___e_c___c_o_m_m_o_n___c_l_o_c_k___s_o_u_r_c_e.html">ADC common - Clock source</a>. Note: The ADC clock configuration is common to all ADC instances. Note: In case of usage of channels on injected group, ADC frequency should be lower than AHB clock frequency /4 for resolution 12 or 10 bits, AHB clock frequency /3 for resolution 8 bits, AHB clock frequency /2 for resolution 6 bits. Note: In case of synchronous clock mode based on HCLK/1, the configuration must be enabled only if the system clock has a 50% duty clock cycle (APB prescaler configured inside RCC must be bypassed and PCLK clock must have 50% duty cycle). Refer to reference manual for details. Note: In case of usage of asynchronous clock, the selected clock must be preliminarily enabled at RCC top level. Note: This parameter can be modified only if all ADC instances are disabled. </p>

</div>
</div>
<a id="a1fc1365e223886a079d7c673f0f90b56" name="a1fc1365e223886a079d7c673f0f90b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc1365e223886a079d7c673f0f90b56">&#9670;&#160;</a></span>ContinuousConvMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FunctionalState ADC_InitTypeDef::ContinuousConvMode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Specify whether the conversion is performed in single mode (one conversion) or continuous mode for ADC group regular, after the first ADC conversion start trigger occurred (software start or external trigger). This parameter can be set to ENABLE or DISABLE. </p>

</div>
</div>
<a id="af9ec9040d55aa68c23d92d174b464ac1" name="af9ec9040d55aa68c23d92d174b464ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ec9040d55aa68c23d92d174b464ac1">&#9670;&#160;</a></span>DataAlign</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ADC_InitTypeDef::DataAlign</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Specify ADC data alignment in conversion data register (right or left). Refer to reference manual for alignments formats versus resolutions. This parameter can be a value of <a class="el" href="group___a_d_c___h_a_l___e_c___d_a_t_a___a_l_i_g_n.html">ADC conversion data alignment</a> </p>

</div>
</div>
<a id="afb62fa7128d7c97d53d2eb170ad467eb" name="afb62fa7128d7c97d53d2eb170ad467eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb62fa7128d7c97d53d2eb170ad467eb">&#9670;&#160;</a></span>DiscontinuousConvMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FunctionalState ADC_InitTypeDef::DiscontinuousConvMode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Specify whether the conversions sequence of ADC group regular is performed in Complete-sequence/Discontinuous-sequence (main sequence subdivided in successive parts). Discontinuous mode is used only if sequencer is enabled (parameter 'ScanConvMode'). If sequencer is disabled, this parameter is discarded. Discontinuous mode can be enabled only if continuous mode is disabled. If continuous mode is enabled, this parameter setting is discarded. This parameter can be set to ENABLE or DISABLE. </p>

</div>
</div>
<a id="a2c35c52d6f47c62915fa7d011e526510" name="a2c35c52d6f47c62915fa7d011e526510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c35c52d6f47c62915fa7d011e526510">&#9670;&#160;</a></span>DMAContinuousRequests</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FunctionalState ADC_InitTypeDef::DMAContinuousRequests</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Specify whether the DMA requests are performed in one shot mode (DMA transfer stops when number of conversions is reached) or in continuous mode (DMA transfer unlimited, whatever number of conversions). This parameter can be set to ENABLE or DISABLE. Note: In continuous mode, DMA must be configured in circular mode. Otherwise an overrun will be triggered when DMA buffer maximum pointer is reached. </p>

</div>
</div>
<a id="ae3eedd269c3acc6c6933e8a252c36e71" name="ae3eedd269c3acc6c6933e8a252c36e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3eedd269c3acc6c6933e8a252c36e71">&#9670;&#160;</a></span>EOCSelection</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ADC_InitTypeDef::EOCSelection</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Specify which EOC (End Of Conversion) flag is used for conversion by polling and interruption: end of unitary conversion or end of sequence conversions. This parameter can be a value of <a class="el" href="group___a_d_c___e_o_c_selection.html">ADC sequencer end of unitary conversion or sequence conversions</a>. </p>

</div>
</div>
<a id="a47aba277f9d8f3c5774983de4ce9455b" name="a47aba277f9d8f3c5774983de4ce9455b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47aba277f9d8f3c5774983de4ce9455b">&#9670;&#160;</a></span>ExternalTrigConv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ADC_InitTypeDef::ExternalTrigConv</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Select the external event source used to trigger ADC group regular conversion start. If set to ADC_SOFTWARE_START, external triggers are disabled and software trigger is used instead. This parameter can be a value of <a class="el" href="group___a_d_c__regular__external__trigger__source.html">ADC group regular trigger source</a>. Caution: external trigger source is common to all ADC instances. </p>

</div>
</div>
<a id="aeed14631d5f1d118a252ea24edd68ede" name="aeed14631d5f1d118a252ea24edd68ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed14631d5f1d118a252ea24edd68ede">&#9670;&#160;</a></span>ExternalTrigConvEdge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ADC_InitTypeDef::ExternalTrigConvEdge</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Select the external event edge used to trigger ADC group regular conversion start. If trigger source is set to ADC_SOFTWARE_START, this parameter is discarded. This parameter can be a value of <a class="el" href="group___a_d_c__regular__external__trigger__edge.html">ADC group regular trigger edge (when external trigger is selected)</a> </p>

</div>
</div>
<a id="ac54504ce05c131459ce3404c416569e9" name="ac54504ce05c131459ce3404c416569e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54504ce05c131459ce3404c416569e9">&#9670;&#160;</a></span>GainCompensation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ADC_InitTypeDef::GainCompensation</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Specify the ADC gain compensation coefficient to be applied to ADC raw conversion data, based on following formula: DATA = DATA(raw) * (gain compensation coef) / 4096 2.12 bit format, unsigned: 2 bits exponents / 12 bits mantissa Gain step is 1/4096 = 0.000244 Gain range is 0.0000 to 3.999756 This parameter value can be 0 Gain compensation will be disabled and coefficient set to 0 1 -&gt; 0x3FFF Gain compensation will be enabled and coefficient set to specified value</p>
<p >Note: Gain compensation when enabled is applied to all channels. </p>

</div>
</div>
<a id="afce1d078350e06a4f8850207d0b81271" name="afce1d078350e06a4f8850207d0b81271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce1d078350e06a4f8850207d0b81271">&#9670;&#160;</a></span>LowPowerAutoWait</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FunctionalState ADC_InitTypeDef::LowPowerAutoWait</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Select the dynamic low power Auto Delay: new conversion start only when the previous conversion (for ADC group regular) or previous sequence (for ADC group injected) has been retrieved by user software, using function HAL_ADC_GetValue() or HAL_ADCEx_InjectedGetValue(). This feature automatically adapts the frequency of ADC conversions triggers to the speed of the system that reads the data. Moreover, this avoids risk of overrun for low frequency applications. This parameter can be set to ENABLE or DISABLE. Note: It is not recommended to use with interruption or DMA (HAL_ADC_Start_IT(), HAL_ADC_Start_DMA()) since these modes have to clear immediately the EOC flag (by CPU to free the IRQ pending event or by DMA). Auto wait will work but fort a very short time, discarding its intended benefit (except specific case of high load of CPU or DMA transfers which can justify usage of auto wait). Do use with polling: 1. Start conversion with HAL_ADC_Start(), 2. Later on, when ADC conversion data is needed: use HAL_ADC_PollForConversion() to ensure that conversion is completed and HAL_ADC_GetValue() to retrieve conversion result and trig another conversion start. (in case of usage of ADC group injected, use the equivalent functions HAL_ADCExInjected_Start(), HAL_ADCEx_InjectedGetValue(), ...). </p>

</div>
</div>
<a id="aa72b0cc3e8dac3a30097cf12093c42a7" name="aa72b0cc3e8dac3a30097cf12093c42a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72b0cc3e8dac3a30097cf12093c42a7">&#9670;&#160;</a></span>NbrOfConversion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ADC_InitTypeDef::NbrOfConversion</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Specify the number of ranks that will be converted within the regular group sequencer. To use the regular group sequencer and convert several ranks, parameter 'ScanConvMode' must be enabled. This parameter must be a number between Min_Data = 1 and Max_Data = 16. Note: This parameter must be modified when no conversion is on going on regular group (ADC disabled, or ADC enabled without continuous mode or external trigger that could launch a conversion). </p>

</div>
</div>
<a id="a5c0078be814bfe2608ae5758826eafb8" name="a5c0078be814bfe2608ae5758826eafb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0078be814bfe2608ae5758826eafb8">&#9670;&#160;</a></span>NbrOfDiscConversion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ADC_InitTypeDef::NbrOfDiscConversion</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Specifies the number of discontinuous conversions in which the main sequence of ADC group regular (parameter NbrOfConversion) will be subdivided. If parameter 'DiscontinuousConvMode' is disabled, this parameter is discarded. This parameter must be a number between Min_Data = 1 and Max_Data = 8. </p>

</div>
</div>
<a id="a63237364ceaf8692adea5dd58420086a" name="a63237364ceaf8692adea5dd58420086a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63237364ceaf8692adea5dd58420086a">&#9670;&#160;</a></span>Overrun</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ADC_InitTypeDef::Overrun</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Select the behavior in case of overrun: data overwritten or preserved (default). This parameter applies to ADC group regular only. This parameter can be a value of <a class="el" href="group___a_d_c___h_a_l___e_c___r_e_g___o_v_r___d_a_t_a___b_e_h_a_v_i_o_r.html">ADC group regular - Overrun behavior on conversion data</a>. Note: In case of overrun set to data preserved and usage with programming model with interruption (HAL_Start_IT()): ADC IRQ handler has to clear end of conversion flags, this induces the release of the preserved data. If needed, this data can be saved in function HAL_ADC_ConvCpltCallback(), placed in user program code (called before end of conversion flags clear). Note: Error reporting with respect to the conversion mode:</p><ul>
<li>Usage with ADC conversion by polling for event or interruption: Error is reported only if overrun is set to data preserved. If overrun is set to data overwritten, user can willingly not read all the converted data, this is not considered as an erroneous case.</li>
<li>Usage with ADC conversion by DMA: Error is reported whatever overrun setting (DMA is expected to process all data from data register). </li>
</ul>

</div>
</div>
<a id="af2b1be3b90d94f331e3688b8f3df528d" name="af2b1be3b90d94f331e3688b8f3df528d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b1be3b90d94f331e3688b8f3df528d">&#9670;&#160;</a></span>Oversampling</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_d_c___oversampling_type_def.html">ADC_OversamplingTypeDef</a> ADC_InitTypeDef::Oversampling</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Specify the Oversampling parameters. Caution: this setting overwrites the previous oversampling configuration if oversampling is already enabled. </p>

</div>
</div>
<a id="a693ef3079c6f2c8588beacb44fce185f" name="a693ef3079c6f2c8588beacb44fce185f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693ef3079c6f2c8588beacb44fce185f">&#9670;&#160;</a></span>OversamplingMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FunctionalState ADC_InitTypeDef::OversamplingMode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Specify whether the oversampling feature is enabled or disabled. This parameter can be set to ENABLE or DISABLE. Note: This parameter can be modified only if there is no conversion is ongoing on ADC groups regular and injected </p>

</div>
</div>
<a id="abebb8d3277cb9a5aae72578076762f5d" name="abebb8d3277cb9a5aae72578076762f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebb8d3277cb9a5aae72578076762f5d">&#9670;&#160;</a></span>Resolution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ADC_InitTypeDef::Resolution</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Configure the ADC resolution. This parameter can be a value of <a class="el" href="group___a_d_c___h_a_l___e_c___r_e_s_o_l_u_t_i_o_n.html">ADC instance - Resolution</a> </p>

</div>
</div>
<a id="a03a8fd245e5e79329d289c3c2381bd0d" name="a03a8fd245e5e79329d289c3c2381bd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a8fd245e5e79329d289c3c2381bd0d">&#9670;&#160;</a></span>SamplingMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ADC_InitTypeDef::SamplingMode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Select the sampling mode to be used for ADC group regular conversion. This parameter can be a value of <a class="el" href="group___a_d_c__regular__sampling__mode.html">ADC group regular sampling mode</a> </p>

</div>
</div>
<a id="a47cd689a52562a2481059a5d8ed82788" name="a47cd689a52562a2481059a5d8ed82788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47cd689a52562a2481059a5d8ed82788">&#9670;&#160;</a></span>ScanConvMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ADC_InitTypeDef::ScanConvMode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Configure the sequencer of ADC groups regular and injected. This parameter can be associated to parameter 'DiscontinuousConvMode' to have main sequence subdivided in successive parts. If disabled: Conversion is performed in single mode (one channel converted, the one defined in rank 1). Parameters 'NbrOfConversion' and 'InjectedNbrOfConversion' are discarded (equivalent to set to 1). If enabled: Conversions are performed in sequence mode (multiple ranks defined by 'NbrOfConversion' or 'InjectedNbrOfConversion' and rank of each channel in sequencer). Scan direction is upward: from rank 1 to rank 'n'. This parameter can be a value of <a class="el" href="group___a_d_c___scan__mode.html">ADC sequencer scan mode</a> </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>C:/Users/alixh/STM32CubeIDE/workspace_1.10.1/TP_Automatique/Drivers/STM32G4xx_HAL_Driver/Inc/<a class="el" href="stm32g4xx__hal__adc_8h_source.html">stm32g4xx_hal_adc.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
